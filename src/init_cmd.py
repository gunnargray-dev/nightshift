"""``awake init`` — bootstrap command — Session 16.

Sets up a new project with awake scaffolding in the target directory:
  - Creates .awake/ directory with config and session log stubs
  - Writes a starter awake.toml configuration
  - Optionally initialises a git repository
  - Prints a getting-started checklist

CLI: awake init [PATH] [--force] [--no-git]
"""

from __future__ import annotations

import json
import os
import subprocess
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional


# ---------------------------------------------------------------------------
# Default file templates
# ---------------------------------------------------------------------------

_AWAKE_TOML = """\
# awake.toml — project configuration
# Generated by `awake init`

[project]
name = "{name}"
created = "{date}"

[health]
threshold = 70           # health score below which CI fails

[sessions]
log_path = ".awake/session_log.json"
health_log_path = ".awake/health_log.json"

[server]
host = "127.0.0.1"
port = 7771
"""

_SESSION_LOG_STUB: dict = {
    "sessions": [],
    "created": "",
    "version": "1.0",
}

_HEALTH_LOG_STUB: list = []

_GITIGNORE_ADDITIONS = [
    "# awake",
    ".awake/cache/",
    ".awake/*.pid",
]


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def _git_is_available() -> bool:
    try:
        subprocess.run(
            ["git", "--version"],
            capture_output=True,
            check=True,
        )
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def _is_git_repo(path: Path) -> bool:
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            capture_output=True,
            cwd=str(path),
        )
        return result.returncode == 0
    except Exception:
        return False


def _append_gitignore(repo_root: Path, additions: list[str]) -> None:
    gi = repo_root / ".gitignore"
    existing = gi.read_text(encoding="utf-8") if gi.exists() else ""
    new_lines = [ln for ln in additions if ln not in existing]
    if new_lines:
        with gi.open("a", encoding="utf-8") as f:
            f.write("\n" + "\n".join(new_lines) + "\n")


# ---------------------------------------------------------------------------
# Core init logic
# ---------------------------------------------------------------------------

class InitError(RuntimeError):
    """Raised when init cannot proceed."""


def run_init(
    target: Optional[Path] = None,
    force: bool = False,
    no_git: bool = False,
) -> list[str]:
    """
    Bootstrap an awake project at *target* (defaults to cwd).

    Returns a list of action strings describing what was done.
    Raises InitError if the directory is already initialised and *force* is False.
    """
    target = (target or Path.cwd()).resolve()
    awake_dir = target / ".awake"
    actions: list[str] = []

    # Guard
    if awake_dir.exists() and not force:
        raise InitError(
            f"{awake_dir} already exists. Use --force to reinitialise."
        )

    # Create directory structure
    for sub in ["", "cache"]:
        (awake_dir / sub).mkdir(parents=True, exist_ok=True)
    actions.append(f"Created {awake_dir}")

    # Write awake.toml
    toml_path = target / "awake.toml"
    if not toml_path.exists() or force:
        toml_path.write_text(
            _AWAKE_TOML.format(name=target.name, date=_now_iso()),
            encoding="utf-8",
        )
        actions.append(f"Written {toml_path}")

    # Write session log stub
    session_log = awake_dir / "session_log.json"
    if not session_log.exists() or force:
        stub = dict(_SESSION_LOG_STUB)
        stub["created"] = _now_iso()
        session_log.write_text(json.dumps(stub, indent=2), encoding="utf-8")
        actions.append(f"Written {session_log}")

    # Write health log stub
    health_log = awake_dir / "health_log.json"
    if not health_log.exists() or force:
        health_log.write_text(json.dumps(_HEALTH_LOG_STUB, indent=2), encoding="utf-8")
        actions.append(f"Written {health_log}")

    # Git init / .gitignore
    if not no_git and _git_is_available():
        if not _is_git_repo(target):
            subprocess.run(["git", "init", str(target)], capture_output=True)
            actions.append(f"Initialised git repo at {target}")
        _append_gitignore(target, _GITIGNORE_ADDITIONS)
        actions.append("Updated .gitignore with awake entries")

    return actions


# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------

def main(args=None) -> int:
    """CLI entry point for `awake init`."""
    import argparse

    parser = argparse.ArgumentParser(
        prog="awake init",
        description="Bootstrap a new awake project",
    )
    parser.add_argument(
        "path", nargs="?", default=None,
        help="Target directory (default: current directory)",
    )
    parser.add_argument(
        "--force", action="store_true",
        help="Reinitialise even if .awake/ already exists",
    )
    parser.add_argument(
        "--no-git", action="store_true",
        help="Skip git initialisation and .gitignore updates",
    )

    parsed = parser.parse_args(args)
    target = Path(parsed.path).resolve() if parsed.path else None

    try:
        actions = run_init(target=target, force=parsed.force, no_git=parsed.no_git)
    except InitError as exc:
        print(f"error: {exc}")
        return 1

    print("awake init — done")
    for action in actions:
        print(f"  ✓ {action}")
    print()
    print("Next steps:")
    print("  awake health          # check code health")
    print("  awake session start   # begin a tracked session")
    print("  awake serve           # start the local API server")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

"""Changelog generator for Awake.

Generates a structured CHANGELOG.md from git history, grouping commits
by session and conventional-commit type.
"""

from __future__ import annotations

import re
import subprocess
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import NamedTuple


# ---------------------------------------------------------------------------
# Data model
# ---------------------------------------------------------------------------


class Commit(NamedTuple):
    sha: str
    date: str
    subject: str
    body: str


COMMIT_TYPES = {
    "feat": "Features",
    "fix": "Bug Fixes",
    "docs": "Documentation",
    "style": "Style",
    "refactor": "Refactoring",
    "perf": "Performance",
    "test": "Tests",
    "build": "Build",
    "ci": "CI",
    "chore": "Chore",
    "revert": "Reverts",
}

# Detect "Session N" references in commit subjects
SESSION_RE = re.compile(r"session\s*(\d+)", re.IGNORECASE)


# ---------------------------------------------------------------------------
# Git helpers
# ---------------------------------------------------------------------------


def _git_log(repo_path: Path) -> list[Commit]:
    """Return all commits from the git log as Commit objects."""
    fmt = "%H%x1f%ad%x1f%s%x1f%b%x1e"
    try:
        out = subprocess.check_output(
            ["git", "log", f"--format={fmt}", "--date=short"],
            cwd=repo_path,
            stderr=subprocess.DEVNULL,
            text=True,
        )
    except subprocess.CalledProcessError:
        return []

    commits: list[Commit] = []
    for record in out.strip().split("\x1e"):
        record = record.strip()
        if not record:
            continue
        parts = record.split("\x1f")
        if len(parts) < 4:
            continue
        sha, date, subject, body = parts[0], parts[1], parts[2], parts[3]
        commits.append(Commit(sha=sha, date=date, subject=subject, body=body))
    return commits


# ---------------------------------------------------------------------------
# Parsing helpers
# ---------------------------------------------------------------------------


def _parse_type(subject: str) -> str:
    """Extract conventional-commit type from a commit subject."""
    m = re.match(r"^(\w+)(?:\(.+\))?!?:", subject)
    if m:
        return m.group(1).lower()
    return "other"


def _parse_session(subject: str, body: str) -> int | None:
    """Extract session number from commit subject or body, if present."""
    for text in (subject, body):
        m = SESSION_RE.search(text)
        if m:
            return int(m.group(1))
    return None


# ---------------------------------------------------------------------------
# Grouping
# ---------------------------------------------------------------------------


def _group_commits(
    commits: list[Commit],
) -> dict[str, dict[str, list[Commit]]]:
    """Group commits by session label then by conventional-commit type.

    Returns a nested dict::

        {
            "Session 5": {"feat": [Commit, ...], "fix": [...]},
            "Unsessioned": {...},
        }
    """
    grouped: dict[str, dict[str, list[Commit]]] = defaultdict(lambda: defaultdict(list))
    for commit in commits:
        session = _parse_session(commit.subject, commit.body)
        session_label = f"Session {session}" if session is not None else "Unsessioned"
        ctype = _parse_type(commit.subject)
        grouped[session_label][ctype].append(commit)
    return dict(grouped)


# ---------------------------------------------------------------------------
# Rendering
# ---------------------------------------------------------------------------


def _render_changelog(grouped: dict[str, dict[str, list[Commit]]]) -> str:
    """Render grouped commits as Markdown text."""
    lines: list[str] = ["# Changelog\n", ""]
    lines.append(
        "_Auto-generated by `awake changelog`. "
        "Do not edit manually._\n"
    )
    lines.append("")

    # Sort sessions: numbered ones first (descending), then Unsessioned
    def _sort_key(label: str) -> tuple[int, int]:
        m = re.match(r"Session (\d+)", label)
        return (0, -int(m.group(1))) if m else (1, 0)

    for session_label in sorted(grouped, key=_sort_key):
        lines.append(f"## {session_label}\n")
        type_map = grouped[session_label]

        for ctype, human in COMMIT_TYPES.items():
            commits_of_type = type_map.get(ctype, [])
            if not commits_of_type:
                continue
            lines.append(f"### {human}\n")
            for c in commits_of_type:
                lines.append(f"- {c.subject} (`{c.sha[:8]}`)")  
            lines.append("")

        other = type_map.get("other", [])
        if other:
            lines.append("### Other\n")
            for c in other:
                lines.append(f"- {c.subject} (`{c.sha[:8]}`)")  
            lines.append("")

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------


def generate_changelog(repo_path: Path | None = None) -> str:
    """Generate a Markdown changelog from git history.

    Args:
        repo_path: Path to the git repository root.  Defaults to the
            current working directory.

    Returns:
        Markdown string containing the full changelog.
    """
    if repo_path is None:
        repo_path = Path(".")
    commits = _git_log(repo_path)
    grouped = _group_commits(commits)
    return _render_changelog(grouped)


def write_changelog(repo_path: Path | None = None, output: Path | None = None) -> Path:
    """Write the changelog to *output* (default: ``CHANGELOG.md``).

    Args:
        repo_path: Repository root directory.
        output: Destination file path.

    Returns:
        The path where the changelog was written.
    """
    if repo_path is None:
        repo_path = Path(".")
    if output is None:
        output = repo_path / "CHANGELOG.md"
    text = generate_changelog(repo_path)
    output.write_text(text, encoding="utf-8")
    return output

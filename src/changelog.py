"""Changelog generator for Nightshift.

Auto-generates CHANGELOG.md from git commit history. Groups commits by type
(feat, fix, refactor, ci, docs, test, meta) and by session number, making it
easy to understand what each overnight run shipped.

Nightshift commit format:
    [nightshift] <type>: <description>

    <body>

    Session: <N>

The generator parses all commits matching `[nightshift]`, groups them by
session and type, and renders a structured Markdown changelog with newest
sessions at the top.
"""

from __future__ import annotations

import re
import subprocess
from dataclasses import dataclass, field, asdict
from pathlib import Path
from typing import Optional


# ---------------------------------------------------------------------------
# Data classes
# ---------------------------------------------------------------------------


@dataclass
class CommitRecord:
    """A single parsed Nightshift commit."""

    sha: str
    subject: str          # Full subject line, e.g. "[nightshift] feat: add stats"
    commit_type: str      # feat | fix | refactor | ci | docs | test | meta | other
    description: str      # The short description after "type: "
    session: int          # Session number extracted from body (0 = unknown)
    body: str = ""        # Full commit body

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class ChangelogSection:
    """A grouped section of commits, usually one session."""

    session: int
    commits_by_type: dict[str, list[CommitRecord]] = field(default_factory=dict)

    def to_dict(self) -> dict:
        return {
            "session": self.session,
            "commits_by_type": {
                k: [c.to_dict() for c in v]
                for k, v in self.commits_by_type.items()
            },
        }

    def total_commits(self) -> int:
        return sum(len(v) for v in self.commits_by_type.values())


@dataclass
class Changelog:
    """Full changelog for the repository."""

    sections: list[ChangelogSection] = field(default_factory=list)
    repo_name: str = "nightshift"
    generated_at: str = ""

    def to_dict(self) -> dict:
        return asdict(self)

    def to_markdown(self) -> str:
        """Render the changelog as a Markdown document."""
        type_labels = {
            "feat": "Features",
            "fix": "Bug Fixes",
            "refactor": "Refactoring",
            "ci": "CI / Infrastructure",
            "docs": "Documentation",
            "test": "Tests",
            "meta": "Meta / Housekeeping",
            "other": "Other",
        }

        lines = [
            f"# Changelog \u2014 {self.repo_name}",
            "",
            "*Auto-generated by Nightshift from git commit history.*",
            "",
        ]

        if not self.sections:
            lines.append("*No Nightshift commits found.*")
            lines += ["", "---", "", f"*Generated: {self.generated_at or 'N/A'}*", ""]
            return "\n".join(lines)

        # Newest sessions first
        for section in sorted(self.sections, key=lambda s: s.session, reverse=True):
            session_label = f"Session {section.session}" if section.session > 0 else "Pre-session"
            lines += [
                f"## {session_label}",
                "",
            ]

            # Emit types in canonical order
            type_order = ["feat", "fix", "refactor", "ci", "docs", "test", "meta", "other"]
            for ctype in type_order:
                commits = section.commits_by_type.get(ctype, [])
                if not commits:
                    continue
                label = type_labels.get(ctype, ctype.title())
                lines += [f"### {label}", ""]
                for commit in commits:
                    sha_short = commit.sha[:7] if commit.sha else "0000000"
                    lines.append(f"- `{sha_short}` {commit.description}")
                lines.append("")

        lines += ["---", "", f"*Generated: {self.generated_at or 'N/A'}*", ""]
        return "\n".join(lines)


# ---------------------------------------------------------------------------
# Parsing functions
# ---------------------------------------------------------------------------

# Matches: [nightshift] feat: some description
SUBJECT_PATTERN = re.compile(
    r"^\[nightshift\]\s+(\w+):\s+(.+)$",
    re.IGNORECASE,
)
SESSION_PATTERN = re.compile(r"Session:\s*(\d+)")


def _run_git(args: list[str], cwd: Optional[Path] = None) -> str:
    """Run a git command and return stdout. Returns empty string on failure."""
    try:
        result = subprocess.run(
            ["git"] + args,
            capture_output=True,
            text=True,
            cwd=cwd or Path.cwd(),
            timeout=30,
        )
        if result.returncode == 0:
            return result.stdout.strip()
        return ""
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return ""


def parse_commit_log(raw_log: str) -> list[CommitRecord]:
    """Parse the output of `git log --pretty=format:%H%x00%s%x00%b%x00`
    into CommitRecord objects.

    The separator `\x00` (null byte) is used to delimit fields within each
    commit entry, and commits are delimited by `\x1e` (record separator).
    """
    records = []
    # Split on the record separator we inject in get_git_log
    entries = raw_log.split("\x1e")

    for entry in entries:
        entry = entry.strip()
        if not entry:
            continue

        parts = entry.split("\x00", maxsplit=2)
        if len(parts) < 2:
            continue

        sha = parts[0].strip()
        subject = parts[1].strip()
        body = parts[2].strip() if len(parts) > 2 else ""

        # Only process Nightshift commits
        subject_match = SUBJECT_PATTERN.match(subject)
        if not subject_match:
            continue

        commit_type = subject_match.group(1).lower()
        description = subject_match.group(2).strip()

        # Extract session number from body
        session_match = SESSION_PATTERN.search(body)
        session_num = int(session_match.group(1)) if session_match else 0

        records.append(
            CommitRecord(
                sha=sha,
                subject=subject,
                commit_type=commit_type,
                description=description,
                session=session_num,
                body=body,
            )
        )

    return records


def get_git_log(repo_path: Optional[Path] = None) -> str:
    """Fetch the full git log in a parseable format."""
    # %H = full SHA, %s = subject, %b = body, %x00 = null separator, %x1e = record sep
    fmt = "%H%x00%s%x00%b%x1e"
    return _run_git(["log", f"--pretty=format:{fmt}"], cwd=repo_path)


def group_by_session(commits: list[CommitRecord]) -> list[ChangelogSection]:
    """Group commit records by session number into ChangelogSection objects."""
    sessions: dict[int, ChangelogSection] = {}

    for commit in commits:
        if commit.session not in sessions:
            sessions[commit.session] = ChangelogSection(session=commit.session)
        section = sessions[commit.session]
        ctype = commit.commit_type
        if ctype not in section.commits_by_type:
            section.commits_by_type[ctype] = []
        section.commits_by_type[ctype].append(commit)

    return list(sessions.values())


def generate_changelog(
    repo_path: Optional[Path] = None,
    *,
    repo_name: str = "nightshift",
    timestamp: str = "",
) -> Changelog:
    """Generate a full Changelog from git commit history.

    Args:
        repo_path: Root of the git repository. Defaults to CWD.
        repo_name: Repository name for the changelog header.
        timestamp: Override timestamp for the generated-at footer.

    Returns:
        Changelog object ready for rendering or saving.
    """
    from datetime import datetime, timezone

    raw_log = get_git_log(repo_path)
    commits = parse_commit_log(raw_log)
    sections = group_by_session(commits)
    ts = timestamp or datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

    return Changelog(sections=sections, repo_name=repo_name, generated_at=ts)


def save_changelog(changelog: Changelog, output_path: Path) -> None:
    """Write the changelog Markdown to disk."""
    output_path.write_text(changelog.to_markdown(), encoding="utf-8")
